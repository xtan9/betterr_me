---
phase: 03-sidebar-collapse-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/layouts/sidebar-layout.tsx
  - components/layouts/sidebar-shell.tsx
  - components/layouts/app-sidebar.tsx
  - app/globals.css
  - i18n/messages/en.json
  - i18n/messages/zh.json
  - i18n/messages/zh-TW.json
autonomous: true

must_haves:
  truths:
    - "Pin/unpin toggle button is visible at the top of the sidebar above the nav list"
    - "Clicking pin toggle collapses/expands the sidebar with smooth animation"
    - "When unpinned, sidebar fully hides and a hover trigger zone on the left edge reveals it as an overlay"
    - "Hover-revealed sidebar overlays content without pushing it"
    - "Pin state persists in a cookie and server reads it to prevent flash of wrong state on reload"
    - "Pin button shows tooltip (Unpin when pinned, Pin when unpinned) and has aria-pressed"
  artifacts:
    - path: "components/layouts/sidebar-layout.tsx"
      provides: "Client component managing pin state, hover state, controlled SidebarProvider, hover trigger zone"
      exports: ["SidebarLayout"]
    - path: "components/layouts/sidebar-shell.tsx"
      provides: "Server component reading sidebar_pinned cookie, delegating to SidebarLayout"
      exports: ["SidebarShell"]
    - path: "components/layouts/app-sidebar.tsx"
      provides: "Pin toggle button in SidebarHeader with Tooltip, aria-pressed, PanelLeftClose/PanelLeft icons"
      exports: ["AppSidebar"]
    - path: "app/globals.css"
      provides: "CSS overrides for hover-overlay mode targeting data-sidebar-hover attribute"
      contains: "data-sidebar-hover"
    - path: "i18n/messages/en.json"
      provides: "English translations for sidebar pin/unpin labels"
      contains: "sidebar.pin"
    - path: "i18n/messages/zh.json"
      provides: "Chinese translations for sidebar pin/unpin labels"
      contains: "sidebar.pin"
    - path: "i18n/messages/zh-TW.json"
      provides: "Traditional Chinese translations for sidebar pin/unpin labels"
      contains: "sidebar.pin"
  key_links:
    - from: "components/layouts/sidebar-shell.tsx"
      to: "components/layouts/sidebar-layout.tsx"
      via: "defaultPinned prop from cookie read"
      pattern: "sidebar_pinned.*SidebarLayout"
    - from: "components/layouts/sidebar-layout.tsx"
      to: "components/layouts/app-sidebar.tsx"
      via: "pinned + onTogglePin + mouse event props"
      pattern: "pinned.*onTogglePin"
    - from: "components/layouts/sidebar-layout.tsx"
      to: "app/globals.css"
      via: "data-sidebar-hover attribute triggers CSS overlay"
      pattern: "data-sidebar-hover"
---

<objective>
Implement the full sidebar pin/unpin collapse system: a new SidebarLayout client component manages pin state (cookie-persisted) and hover-reveal state, SidebarShell reads the pin cookie server-side, AppSidebar gets a pin toggle button with Chameleon-style accessibility, and CSS overrides enable the hover-overlay reveal mode.

Purpose: Users can control screen real estate by collapsing the sidebar, with their preference remembered. When unpinned, the sidebar fully hides and reveals on hover as an overlay. This is the core interaction pattern for Phase 3.

Output: Complete pin/unpin collapse system with cookie persistence, hover-reveal overlay, i18n support, and smooth animations.
</objective>

<execution_context>
@/home/xingdi/.claude/get-shit-done/workflows/execute-plan.md
@/home/xingdi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-sidebar-collapse-persistence/03-RESEARCH.md
@.planning/phases/03-sidebar-collapse-persistence/03-CONTEXT.md
@.planning/phases/02-sidebar-shell-navigation-switch/02-01-SUMMARY.md

# Key source files to read before implementing:
@components/layouts/sidebar-shell.tsx
@components/layouts/app-sidebar.tsx
@components/ui/sidebar.tsx
@app/globals.css
@i18n/messages/en.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SidebarLayout client component, refactor SidebarShell, add hover overlay CSS</name>
  <files>
    components/layouts/sidebar-layout.tsx
    components/layouts/sidebar-shell.tsx
    app/globals.css
  </files>
  <action>
**Create `components/layouts/sidebar-layout.tsx`** (new client component):

This is the state management hub for the sidebar. Architecture:

```
SidebarLayout (client component)
  |-- manages: pinned (boolean, cookie-persisted)
  |-- manages: hoverOpen (boolean, NOT persisted)
  |-- derives: open = pinned || hoverOpen
  |-- renders SidebarProvider with controlled open + onOpenChange
  |-- renders hover trigger zone when !pinned && !hoverOpen
  |-- wraps AppSidebar with pin/hover props + mouse events on sidebar wrapper
```

Props: `{ defaultPinned: boolean; children: React.ReactNode }`

State management:
- `pinned` state initialized from `defaultPinned` prop (which comes from server cookie read)
- `hoverOpen` state for temporary hover reveal (never persisted)
- Derived `open = pinned || hoverOpen`
- Use controlled `SidebarProvider` (`open={open}`, `onOpenChange={handleOpenChange}`)
- `onOpenChange` handler: only respond to mobile sheet toggles (set `setOpenMobile` equivalent). For desktop, pin+hover manage state. Actually, per research Pitfall 2, in controlled mode the internal `setOpen` still writes cookies. To handle this cleanly: intercept `onOpenChange` and only persist when it's a deliberate pin toggle, not a hover. One approach: `onOpenChange` does nothing for desktop (pin button handles state), and for mobile it passes through normally. BUT since controlled mode means `open` prop is the source of truth, `onOpenChange` is just a callback -- we can use it to detect mobile sheet close.

Cookie persistence:
- Cookie name: `sidebar_pinned` (separate from shadcn's `sidebar_state` to avoid Pitfall 2 conflicts)
- Max age: 7 days (`60 * 60 * 24 * 7`)
- Write cookie on pin toggle: `document.cookie = "sidebar_pinned=${newPinned}; path=/; max-age=${maxAge}"`

Pin toggle handler (`handleTogglePin`):
- Toggle `pinned` state
- Write cookie
- When unpinning (`newPinned = false`), also set `hoverOpen = false` to dismiss sidebar

Hover handlers (desktop only):
- `handleMouseEnter`: if `!pinned`, set `hoverOpen = true`
- `handleMouseLeave`: if `!pinned`, set `hoverOpen = false`

Render structure:
```tsx
<SidebarProvider open={open} onOpenChange={handleOpenChange}>
  <div
    data-sidebar-hover={!pinned && hoverOpen ? "true" : undefined}
    onMouseEnter={handleMouseEnter}
    onMouseLeave={handleMouseLeave}
  >
    <AppSidebar pinned={pinned} onTogglePin={handleTogglePin} />
  </div>
  {/* Hover trigger zone -- only when unpinned and not currently hovering */}
  {!pinned && !hoverOpen && (
    <div
      className="fixed inset-y-0 left-0 z-20 hidden w-[22px] md:block"
      onMouseEnter={handleMouseEnter}
      aria-hidden="true"
    />
  )}
  <SidebarInset>
    <header className="flex h-14 shrink-0 items-center gap-2 border-b px-4 md:hidden">
      <SidebarTrigger className="-ml-1" />
      <span className="font-display font-bold text-lg text-primary">BetterR.me</span>
    </header>
    <div className="flex-1 p-4 md:p-6">{children}</div>
  </SidebarInset>
</SidebarProvider>
```

Note: The `data-sidebar-hover` wrapper div wraps `<AppSidebar>` (which renders `<Sidebar>`). The mouse enter/leave events on this wrapper handle the dismiss-on-leave behavior. The hover trigger zone is a separate fixed div for initial detection.

**Refactor `components/layouts/sidebar-shell.tsx`** (server component):

Simplify to read the `sidebar_pinned` cookie and delegate to SidebarLayout:

```tsx
import { cookies } from "next/headers";
import { SidebarLayout } from "@/components/layouts/sidebar-layout";

export async function SidebarShell({ children }: { children: React.ReactNode }) {
  const cookieStore = await cookies();
  const pinnedCookie = cookieStore.get("sidebar_pinned")?.value;
  const defaultPinned = pinnedCookie !== "false"; // Default to pinned for first-time visitors

  return (
    <SidebarLayout defaultPinned={defaultPinned}>
      {children}
    </SidebarLayout>
  );
}
```

Remove direct `SidebarProvider`, `SidebarInset`, `SidebarTrigger`, `AppSidebar` imports -- all now inside SidebarLayout.

**Add hover overlay CSS to `app/globals.css`**:

Add these rules after the existing sidebar CSS variables section (after the `:root` and `.dark` blocks, before `@layer base`). Target the `data-sidebar-hover` attribute set by SidebarLayout:

```css
/* Sidebar hover-overlay mode: when unpinned, sidebar overlays content on hover */
[data-sidebar-hover="true"] .peer[data-state="collapsed"][data-collapsible="offcanvas"] > div:last-child {
  left: 0;
  z-index: 30;
  box-shadow: 4px 0 16px rgba(0, 0, 0, 0.08);
  transition: left 150ms ease-in-out;
}

.dark [data-sidebar-hover="true"] .peer[data-state="collapsed"][data-collapsible="offcanvas"] > div:last-child {
  box-shadow: 4px 0 16px rgba(0, 0, 0, 0.3);
}
```

IMPORTANT: The `<Sidebar>` component renders as `<div class="group peer ...">` with children: (1) gap div, (2) fixed sidebar div. When `data-collapsible="offcanvas"` and `state="collapsed"`, the fixed sidebar div has `left: calc(var(--sidebar-width) * -1)` (hidden off-screen). The CSS override above moves it back to `left: 0` when the hover wrapper has `data-sidebar-hover="true"`.

Note on timing: The existing shadcn sidebar uses `duration-200 ease-linear` for transitions. The hover overlay CSS uses `150ms ease-in-out` per user decision. The difference is intentional -- hover reveal should feel snappy (150ms ease-in-out) while the base sidebar animation uses shadcn defaults. Per Claude's Discretion, accept this slight inconsistency rather than modifying the shadcn managed file.

Note on SidebarProvider controlled mode and Pitfall 2: When using controlled mode (`open` prop), shadcn's internal `setOpen` still writes the `sidebar_state` cookie. Since we use a SEPARATE `sidebar_pinned` cookie, the `sidebar_state` cookie writes are harmless noise. Our server component reads `sidebar_pinned`, not `sidebar_state`. This avoids the cookie conflict pitfall entirely.
  </action>
  <verify>
Run `pnpm build` to verify TypeScript compilation and no import errors. Manually verify:
1. `sidebar-layout.tsx` exports `SidebarLayout` component
2. `sidebar-shell.tsx` reads `sidebar_pinned` cookie and renders `SidebarLayout`
3. `globals.css` contains `[data-sidebar-hover="true"]` CSS rule
  </verify>
  <done>
SidebarLayout client component exists with pin state management, hover trigger zone, and controlled SidebarProvider. SidebarShell reads sidebar_pinned cookie and delegates to SidebarLayout. CSS overlay rules exist for hover-reveal mode. Build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pin toggle button to AppSidebar and i18n translations</name>
  <files>
    components/layouts/app-sidebar.tsx
    i18n/messages/en.json
    i18n/messages/zh.json
    i18n/messages/zh-TW.json
  </files>
  <action>
**Update `components/layouts/app-sidebar.tsx`**:

Add new props to AppSidebar: `pinned: boolean` and `onTogglePin: () => void`.

Update the component signature:
```tsx
interface AppSidebarProps {
  pinned: boolean;
  onTogglePin: () => void;
}

export function AppSidebar({ pinned, onTogglePin }: AppSidebarProps) {
```

Add imports:
- `PanelLeftClose, PanelLeft` from `lucide-react` (alongside existing Home, ClipboardList, ListChecks)
- `Tooltip, TooltipTrigger, TooltipContent, TooltipProvider` from `@/components/ui/tooltip`

Add a second `useTranslations` call for sidebar keys: `const tSidebar = useTranslations("common.sidebar");`

In `SidebarHeader`, add a pin toggle button next to the brand text. The header becomes a flex row with brand text on left and pin button on right:

```tsx
<SidebarHeader>
  <div className="flex items-center justify-between px-2 py-1">
    <span className="font-display font-bold text-lg text-primary">
      BetterR.me
    </span>
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <button
            onClick={onTogglePin}
            aria-pressed={pinned}
            aria-label={pinned ? tSidebar("unpinLabel") : tSidebar("pinLabel")}
            className="inline-flex h-7 w-7 items-center justify-center rounded-md text-sidebar-foreground/70 hover:bg-sidebar-accent hover:text-sidebar-accent-foreground transition-colors"
          >
            {pinned ? <PanelLeftClose className="size-4" /> : <PanelLeft className="size-4" />}
          </button>
        </TooltipTrigger>
        <TooltipContent side="right">
          {pinned ? tSidebar("unpin") : tSidebar("pin")}
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  </div>
</SidebarHeader>
```

Per locked decision: button at the top of sidebar, above nav list, with tooltip showing "Unpin" when pinned / "Pin" when unpinned, and `aria-pressed` for accessibility. Icons: `PanelLeftClose` (pinned state -- "close/collapse the panel") and `PanelLeft` (unpinned state -- "open/expand the panel").

Per locked decision: "A compact icon/logo remains visible at the top in collapsed mode (not hidden)" -- the BetterR.me text is in SidebarHeader which is visible in all states. When collapsed (offcanvas mode), the entire sidebar is hidden, so this only applies to the pinned expanded state.

Also update the `<Sidebar>` element to use `collapsible="offcanvas"` explicitly:
```tsx
<Sidebar collapsible="offcanvas">
```

This ensures that when `open=false` (unpinned), the sidebar fully hides (gap collapses to 0, sidebar slides off-screen) rather than showing an icon rail.

**Add i18n translations to all 3 locale files**:

Add under `common` section (alongside existing `nav`):

**en.json** -- add `sidebar` key inside `common`:
```json
"sidebar": {
  "pin": "Pin",
  "unpin": "Unpin",
  "pinLabel": "Pin sidebar navigation. Currently unpinned.",
  "unpinLabel": "Unpin sidebar navigation. Currently pinned."
}
```

**zh.json** -- add `sidebar` key inside `common`:
```json
"sidebar": {
  "pin": "固定",
  "unpin": "取消固定",
  "pinLabel": "固定侧边栏导航。当前未固定。",
  "unpinLabel": "取消固定侧边栏导航。当前已固定。"
}
```

**zh-TW.json** -- add `sidebar` key inside `common`:
```json
"sidebar": {
  "pin": "釘選",
  "unpin": "取消釘選",
  "pinLabel": "釘選側邊欄導航。目前未釘選。",
  "unpinLabel": "取消釘選側邊欄導航。目前已釘選。"
}
```

These follow Chameleon's accessibility pattern: "Unpin sidebar navigation. Currently pinned." as the aria-label, with short "Pin"/"Unpin" for the tooltip.
  </action>
  <verify>
Run `pnpm build` to confirm TypeScript compilation. Run `pnpm lint` and fix any lint errors. Verify:
1. `app-sidebar.tsx` has pin toggle button with `aria-pressed`, `PanelLeftClose`/`PanelLeft` icons, Tooltip
2. All 3 locale files have `common.sidebar.pin`, `.unpin`, `.pinLabel`, `.unpinLabel` keys
3. `<Sidebar collapsible="offcanvas">` is set
  </verify>
  <done>
AppSidebar renders a pin toggle button at the top of the sidebar with tooltip, aria-pressed, and Chameleon-style accessibility labels. All three locale files have pin/unpin translation keys. The sidebar uses collapsible="offcanvas" mode. Build and lint pass.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `pnpm build` passes -- all TypeScript compiles, no import errors
2. `pnpm lint` passes -- no lint warnings or errors
3. `pnpm test:run` passes -- existing tests still work (may need mock updates if AppSidebar now requires props)
4. Manual verification: the pin toggle button is in the sidebar header, CSS overlay rules exist in globals.css, cookie read/write logic is in place, all 3 locales have the new keys
</verification>

<success_criteria>
- SidebarLayout client component manages pin state (cookie-persisted) and hover-reveal state (transient)
- SidebarShell reads sidebar_pinned cookie server-side and passes defaultPinned to SidebarLayout
- Pin toggle button in AppSidebar header with Tooltip, aria-pressed, PanelLeftClose/PanelLeft icons
- CSS overlay rules in globals.css target data-sidebar-hover for hover-reveal mode
- All 3 locale files have pin/unpin translation keys
- Build and lint pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-sidebar-collapse-persistence/03-01-SUMMARY.md`
</output>
