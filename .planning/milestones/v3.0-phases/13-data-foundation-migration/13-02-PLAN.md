---
phase: 13-data-foundation-migration
plan: 02
type: execute
wave: 2
depends_on:
  - 13-01
files_modified:
  - lib/db/tasks.ts
  - app/api/tasks/route.ts
  - app/api/tasks/[id]/route.ts
  - lib/recurring-tasks/instance-generator.ts
  - tests/lib/db/tasks.test.ts
  - tests/app/api/tasks/route.test.ts
  - tests/app/api/tasks/[id]/route.test.ts
  - tests/lib/validations/task.test.ts
autonomous: true
requirements:
  - DATA-03
  - DATA-04

must_haves:
  truths:
    - "Setting status=done via PATCH API sets is_completed=true and records completed_at"
    - "Moving status away from done via PATCH API clears is_completed and completed_at"
    - "Toggling a task complete via POST /toggle sets status=done"
    - "Toggling a task incomplete via POST /toggle sets status=todo"
    - "Creating a task via POST /api/tasks sets status=todo and section=personal by default"
    - "Recurring task instances are created with status=todo and section=personal"
    - "Dashboard task counts, sidebar counts, and all existing features work identically"
    - "All existing task API tests pass without behavioral regression"
  artifacts:
    - path: "lib/db/tasks.ts"
      provides: "Task DB layer with sync integration"
      contains: "syncTaskUpdate"
    - path: "app/api/tasks/route.ts"
      provides: "POST handler with sync + sort_order"
      contains: "syncTaskCreate"
    - path: "app/api/tasks/[id]/route.ts"
      provides: "PATCH handler with sync"
      contains: "syncTaskUpdate"
    - path: "lib/recurring-tasks/instance-generator.ts"
      provides: "Instance generator with new fields"
      contains: "status.*todo"
  key_links:
    - from: "lib/db/tasks.ts"
      to: "lib/tasks/sync.ts"
      via: "toggleTaskCompletion calls syncTaskUpdate"
      pattern: "import.*syncTaskUpdate.*from.*@/lib/tasks/sync"
    - from: "app/api/tasks/route.ts"
      to: "lib/tasks/sync.ts"
      via: "POST handler calls syncTaskCreate"
      pattern: "import.*syncTaskCreate.*from.*@/lib/tasks/sync"
    - from: "app/api/tasks/[id]/route.ts"
      to: "lib/tasks/sync.ts"
      via: "PATCH handler calls syncTaskUpdate"
      pattern: "import.*syncTaskUpdate.*from.*@/lib/tasks/sync"
    - from: "lib/recurring-tasks/instance-generator.ts"
      to: "lib/db/types.ts"
      via: "TaskInsert includes status and section fields"
      pattern: "status:.*'todo'"
---

<objective>
Wire the sync utility into every task mutation point (DB layer, API routes, instance generator) and update all existing tests for backward compatibility.

Purpose: This is the critical integration step that makes the bidirectional is_completed/status sync actually work in production. Every code path that creates or updates a task must go through the sync layer. Existing tests must pass with only mock object updates (no assertion changes), proving backward compatibility (DATA-04).

Output: All 7 mutation points wired to sync, all existing tests passing, backward compatibility verified.
</objective>

<execution_context>
@/home/xingdi/.claude/get-shit-done/workflows/execute-plan.md
@/home/xingdi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-data-foundation-migration/13-RESEARCH.md
@.planning/phases/13-data-foundation-migration/13-01-SUMMARY.md

@lib/db/tasks.ts
@lib/tasks/sync.ts
@app/api/tasks/route.ts
@app/api/tasks/[id]/route.ts
@app/api/tasks/[id]/toggle/route.ts
@lib/recurring-tasks/instance-generator.ts
@tests/lib/db/tasks.test.ts
@tests/app/api/tasks/route.test.ts
@tests/app/api/tasks/[id]/route.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire sync into DB layer and API routes</name>
  <files>lib/db/tasks.ts, app/api/tasks/route.ts, app/api/tasks/[id]/route.ts, lib/recurring-tasks/instance-generator.ts</files>
  <action>
**1. Update `lib/db/tasks.ts`:**

Import sync function:
```typescript
import { syncTaskUpdate } from '@/lib/tasks/sync';
```

Update `toggleTaskCompletion()` to include status sync:
```typescript
async toggleTaskCompletion(taskId: string, userId: string): Promise<Task> {
  const task = await this.getTask(taskId, userId);
  if (!task) throw new Error('Task not found');

  const updates: TaskUpdate = {
    is_completed: !task.is_completed,
  };

  // Apply sync to keep status consistent with is_completed
  const syncedUpdates = syncTaskUpdate(updates);
  return this.updateTask(taskId, userId, syncedUpdates);
}
```

The key change: instead of manually setting `completed_at` and `is_completed`, pass `{ is_completed: !task.is_completed }` through `syncTaskUpdate()` which handles setting `status`, `completed_at`, and `is_completed` consistently.

**2. Update `app/api/tasks/route.ts` (POST handler):**

Import sync and sort-order:
```typescript
import { syncTaskCreate } from '@/lib/tasks/sync';
import { getBottomSortOrder } from '@/lib/tasks/sort-order';
```

After building `taskData`, apply sync and sort order before creating:
```typescript
// Query max sort_order for this user to place new task at bottom
const { data: maxRow } = await supabase
  .from('tasks')
  .select('sort_order')
  .eq('user_id', user.id)
  .order('sort_order', { ascending: false })
  .limit(1)
  .maybeSingle();

const taskData: TaskInsert = {
  user_id: user.id,
  title: validation.data.title.trim(),
  description: validation.data.description?.trim() || null,
  intention: validation.data.intention?.trim() || null,
  is_completed: false,
  priority: validation.data.priority ?? 0,
  category: validation.data.category || null,
  due_date: validation.data.due_date || null,
  due_time: validation.data.due_time || null,
  status: validation.data.status,       // Forward compat: accept from request
  sort_order: getBottomSortOrder(maxRow?.sort_order ?? null),
};

// Apply sync to ensure status/is_completed/completed_at consistency
const syncedTask = syncTaskCreate(taskData);
const task = await tasksDB.createTask(syncedTask);
```

**3. Update `app/api/tasks/[id]/route.ts` (PATCH handler):**

Import sync:
```typescript
import { syncTaskUpdate } from '@/lib/tasks/sync';
```

Add status handling after the existing `completion_difficulty` block:
```typescript
if (validation.data.status !== undefined) {
  updates.status = validation.data.status;
}
if (validation.data.section !== undefined) {
  updates.section = validation.data.section;
}
if (validation.data.sort_order !== undefined) {
  updates.sort_order = validation.data.sort_order;
}
```

Then apply sync AFTER all updates are collected, BEFORE the DB write:
```typescript
// Apply sync to keep status/is_completed consistent
const syncedUpdates = syncTaskUpdate(updates);
const task = await tasksDB.updateTask(id, user.id, syncedUpdates);
```

This replaces the existing manual `completed_at` logic in the `is_completed` block. Remove the old manual `completed_at` setting:
```typescript
// BEFORE (remove this):
if (validation.data.is_completed !== undefined) {
  updates.is_completed = validation.data.is_completed;
  updates.completed_at = validation.data.is_completed ? new Date().toISOString() : null;
}

// AFTER (replace with):
if (validation.data.is_completed !== undefined) {
  updates.is_completed = validation.data.is_completed;
}
```

The sync layer now handles `completed_at` automatically.

**4. Update `lib/recurring-tasks/instance-generator.ts`:**

Add `status: 'todo' as const` and `section: 'personal'` to the `newInstances` map in `generateInstancesForTemplate()`:

```typescript
const newInstances: TaskInsert[] = allowedOccurrences
  .filter(date => !existingDates.has(date))
  .map(date => ({
    user_id: userId,
    title: template.title,
    description: template.description,
    intention: template.intention,
    priority: template.priority,
    category: template.category,
    due_date: date,
    due_time: template.due_time,
    is_completed: false,
    status: 'todo' as const,     // Phase 13: recurring instances start as todo
    section: 'personal',          // Phase 13: default section
    recurring_task_id: template.id,
    is_exception: false,
    original_date: date,
  }));
```

Note: sort_order for recurring instances uses the DB default (0) initially. This is acceptable because:
- Recurring instances have due_date ordering which takes precedence in current views
- Phase 15 (kanban) will assign proper sort_order when tasks are moved between columns

Run `pnpm lint` to verify compilation.
  </action>
  <verify>
Run `pnpm lint` — no errors. All production files compile correctly with the sync wiring.
  </verify>
  <done>
All 7 mutation points are wired to the sync layer: (1) toggleTaskCompletion in DB layer, (2) PATCH handler's is_completed branch, (3) PATCH handler's status branch, (4) POST handler's task creation, (5) instance generator's bulk insert. The PATCH handler's old manual completed_at logic is replaced by syncTaskUpdate. POST handler computes sort_order for new tasks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update existing tests for backward compatibility and add sync integration tests</name>
  <files>tests/lib/db/tasks.test.ts, tests/app/api/tasks/route.test.ts, tests/app/api/tasks/[id]/route.test.ts, tests/lib/validations/task.test.ts</files>
  <action>
**Strategy:** Update mock task objects to include the 3 new fields (`status`, `section`, `sort_order`). Existing test assertions should NOT change (proving backward compatibility). Then add NEW tests for sync behavior.

**1. Update mock task objects across all test files:**

Every mock `Task` object in tests needs 3 new fields. Find all mock task objects and add:
```typescript
status: 'todo',      // or 'done' if is_completed: true
section: 'personal',
sort_order: 65536.0,
```

Important: If a mock task has `is_completed: true`, set `status: 'done'`. If `is_completed: false`, set `status: 'todo'`. This mirrors the migration behavior and keeps mocks realistic.

Files to update:
- `tests/lib/db/tasks.test.ts` — update all `mockTask` / mock task objects
- `tests/app/api/tasks/route.test.ts` — update all mock task responses
- `tests/app/api/tasks/[id]/route.test.ts` — update all mock task objects
- `tests/lib/validations/task.test.ts` — may need updates if task validation tests exist

**2. Update `tests/app/api/tasks/route.test.ts` (POST tests):**

The POST handler now queries `max(sort_order)` before creating. Update the Supabase mock chain to handle:
- The `select('sort_order').eq().order().limit().maybeSingle()` call for max sort_order
- Verify the mock accounts for the additional Supabase call

Add new test: "POST creates task with status=todo and section=personal by default"
- Verify the mock `insert` call receives an object containing `status: 'todo'`, `section: 'personal'`, `sort_order: 65536.0`

Add new test: "POST accepts status in request body for forward compatibility"
- Send `{ title: 'Test', status: 'backlog' }` → verify insert receives `status: 'backlog'`, `is_completed: false`

**3. Update `tests/app/api/tasks/[id]/route.test.ts` (PATCH tests):**

Existing PATCH tests for `is_completed` should still pass — the sync layer produces the same `completed_at` behavior.

Add new test: "PATCH with status=done sets is_completed=true"
- Send `{ status: 'done' }` → verify update receives `status: 'done'`, `is_completed: true`, `completed_at: expect.any(String)`

Add new test: "PATCH with status=todo clears is_completed"
- Send `{ status: 'todo' }` → verify update receives `status: 'todo'`, `is_completed: false`, `completed_at: null`

**4. Update `tests/lib/db/tasks.test.ts` (toggleTaskCompletion tests):**

The toggle now goes through syncTaskUpdate, which adds `status` to the update call. Update the mock expectations:
- When toggling incomplete → complete: verify `updateTask` receives `{ is_completed: true, status: 'done', completed_at: expect.any(String) }`
- When toggling complete → incomplete: verify `updateTask` receives `{ is_completed: false, status: 'todo', completed_at: null }`

**5. Run full test suite:**
```bash
pnpm test:run
```

All existing tests must pass. The ONLY changes to existing assertions should be where mock objects gain the 3 new fields and where toggle/update assertions now include `status` in the expected update payload.
  </action>
  <verify>
Run `pnpm test:run` — ALL tests pass (including existing habit, dashboard, auth tests). Run `pnpm lint` — no errors. Specifically verify:
- `pnpm test:run -- tests/app/api/tasks/route.test.ts` — passes
- `pnpm test:run -- tests/app/api/tasks/[id]/route.test.ts` — passes
- `pnpm test:run -- tests/lib/db/tasks.test.ts` — passes
- `pnpm test:run -- tests/app/api/dashboard/route.test.ts` — passes (untouched, backward compat)
- `pnpm test:run -- tests/app/api/sidebar/counts/route.test.ts` — passes (untouched, backward compat)
  </verify>
  <done>
All existing tests pass with updated mock objects (proving backward compatibility — DATA-04). New sync integration tests verify: (1) POST creates with status=todo/section=personal/sort_order, (2) PATCH status=done syncs is_completed=true, (3) PATCH status=todo clears is_completed, (4) toggle sets status=done/todo alongside is_completed, (5) forward-compat status acceptance in POST. Dashboard and sidebar tests pass untouched.
  </done>
</task>

</tasks>

<verification>
1. `pnpm lint` passes — no type or lint errors
2. `pnpm test:run` — ALL tests pass (existing + new)
3. Dashboard route test passes untouched — dashboard stats unaffected (DATA-04)
4. Sidebar counts route test passes untouched — sidebar counts unaffected (DATA-04)
5. Toggle route integration: toggling complete sets status=done, toggling incomplete sets status=todo (DATA-03)
6. PATCH with status=done → is_completed=true + completed_at set (DATA-03)
7. PATCH with status away from done → is_completed=false + completed_at=null (DATA-03)
8. POST creates tasks with status=todo, section=personal, sort_order computed (DATA-01 forward compat)
9. Recurring instances include status=todo, section=personal (DATA-04)
</verification>

<success_criteria>
- All 7 mutation points wired to sync layer (toggleTaskCompletion, PATCH is_completed, PATCH status, POST create, instance generator, plus the scope-based PATCH passes through existing update which now gets synced)
- All existing tests pass — no behavioral regressions
- New sync integration tests pass — sync behavior verified at API layer
- Dashboard and sidebar tests pass untouched — backward compatibility proven
</success_criteria>

<output>
After completion, create `.planning/phases/13-data-foundation-migration/13-02-SUMMARY.md`
</output>
