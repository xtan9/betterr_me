---
phase: 04-performance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/tasks.ts
  - app/api/dashboard/route.ts
  - app/dashboard/page.tsx
  - tests/app/api/dashboard/route.test.ts
  - tests/lib/db/tasks.test.ts
autonomous: true

must_haves:
  truths:
    - "The dashboard API route returns correct total_tasks and tasks_completed_today without fetching all task rows"
    - "The SSR dashboard page returns the same stats shape without fetching all task rows"
    - "DashboardData type and frontend components are unchanged"
  artifacts:
    - path: "lib/db/tasks.ts"
      provides: "getTaskCount method using HEAD-only COUNT query"
      contains: "count: 'exact', head: true"
    - path: "app/api/dashboard/route.ts"
      provides: "Dashboard API using getTaskCount instead of getUserTasks for counts"
      contains: "getTaskCount"
    - path: "app/dashboard/page.tsx"
      provides: "SSR dashboard using getTaskCount instead of getUserTasks for counts"
      contains: "getTaskCount"
  key_links:
    - from: "app/api/dashboard/route.ts"
      to: "lib/db/tasks.ts"
      via: "tasksDB.getTaskCount() calls"
      pattern: "tasksDB\\.getTaskCount"
    - from: "app/dashboard/page.tsx"
      to: "lib/db/tasks.ts"
      via: "tasksDB.getTaskCount() calls"
      pattern: "tasksDB\\.getTaskCount"
---

<objective>
Replace full task row fetches with COUNT(*) HEAD queries in the dashboard route and SSR page for task counts.

Purpose: The dashboard fetches all task rows just to get `.length` for `total_tasks` and `tasks_completed_today`. This transfers unnecessary data. Supabase supports `{ count: 'exact', head: true }` to return only counts -- a pattern already used in the codebase (see `getActiveHabitCount`, `countCompletedLogs`).

Output: `getTaskCount()` method on TasksDB, dashboard route and SSR page updated to use it, tests updated.
</objective>

<execution_context>
@/home/xingdi/.claude/get-shit-done/workflows/execute-plan.md
@/home/xingdi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-performance/04-RESEARCH.md

@lib/db/tasks.ts
@lib/db/types.ts
@app/api/dashboard/route.ts
@app/dashboard/page.tsx
@tests/app/api/dashboard/route.test.ts
@tests/lib/db/tasks.test.ts
@tests/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getTaskCount method to TasksDB and wire into both dashboard codepaths</name>
  <files>lib/db/tasks.ts, app/api/dashboard/route.ts, app/dashboard/page.tsx</files>
  <action>
**1. Add `getTaskCount` to `lib/db/tasks.ts`:**

Add a new method after `getUserTasks` (around line 40). It mirrors the filter logic of `getUserTasks` but uses `{ count: 'exact', head: true }` instead of `select('*')`. Follow the exact pattern from `getActiveHabitCount` in `lib/db/habits.ts`:

```typescript
async getTaskCount(userId: string, filters?: TaskFilters): Promise<number> {
  let query = this.supabase
    .from('tasks')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId);

  if (filters) {
    if (filters.is_completed !== undefined) {
      query = query.eq('is_completed', filters.is_completed);
    }
    if (filters.priority !== undefined) {
      query = query.eq('priority', filters.priority);
    }
    if (filters.due_date) {
      query = query.eq('due_date', filters.due_date);
    }
    if (filters.has_due_date !== undefined) {
      query = filters.has_due_date
        ? query.not('due_date', 'is', null)
        : query.is('due_date', null);
    }
  }

  const { count, error } = await query;
  if (error) throw error;
  return count ?? 0;
}
```

No new types needed -- `TaskFilters` already has `is_completed`, `due_date`, etc.

**2. Update `app/api/dashboard/route.ts` (lines 60-69):**

Replace the two `getUserTasks` calls used only for counting:

Before:
```
tasksDB.getUserTasks(user.id, { due_date: date }),   // allTodayTasks
tasksDB.getUserTasks(user.id),                        // allTasks
```

After:
```
tasksDB.getTaskCount(user.id, { due_date: date, is_completed: true }),  // tasksCompletedTodayCount
tasksDB.getTaskCount(user.id),                                          // totalTaskCount
```

Update the destructured variable names from `allTodayTasks, allTasks` to `tasksCompletedTodayCount, totalTaskCount`.

Update the stats calculation (around line 123):
- Remove: `const tasksCompletedToday = allTodayTasks.filter(t => t.is_completed).length;`
- Change `total_tasks: allTasks.length` to `total_tasks: totalTaskCount`
- Change `tasks_completed_today: tasksCompletedToday` to `tasks_completed_today: tasksCompletedTodayCount`

IMPORTANT (Pitfall 4 from research): The count for `tasks_completed_today` needs BOTH `due_date` AND `is_completed: true` filters. Do NOT just count all tasks for today -- that gives `tasks_due_today`, not `tasks_completed_today`.

**3. Update `app/dashboard/page.tsx` (lines 30-41):**

Same pattern as the API route. Replace:
```
tasksDB.getUserTasks(user.id, { due_date: date }),   // allTodayTasks
tasksDB.getUserTasks(user.id),                        // allTasks
```

With:
```
tasksDB.getTaskCount(user.id, { due_date: date, is_completed: true }),  // tasksCompletedTodayCount
tasksDB.getTaskCount(user.id),                                          // totalTaskCount
```

Update the stats section (around lines 50-52):
- Remove: `const tasksCompletedToday = allTodayTasks.filter((t) => t.is_completed).length;`
- Change `total_tasks: allTasks.length` to `total_tasks: totalTaskCount`
- Change `tasks_completed_today: tasksCompletedToday` to `tasks_completed_today: tasksCompletedTodayCount`

Keep `todayTasks` and `tasksTomorrow` calls unchanged -- those return actual rows needed for rendering.
  </action>
  <verify>Run `pnpm lint` to confirm no type errors. Run `pnpm build` to confirm the build succeeds. Grep for `getUserTasks(user.id)` without filters in both dashboard files to confirm no count-only calls remain (the only remaining `getUserTasks` calls should have filters for rows needed for rendering, like `tomorrowStr` tasks).</verify>
  <done>Both dashboard codepaths use `getTaskCount` for `total_tasks` and `tasks_completed_today`. No `getUserTasks` calls exist that are only used for `.length`. Build and lint pass.</done>
</task>

<task type="auto">
  <name>Task 2: Update dashboard route tests and add getTaskCount unit tests</name>
  <files>tests/app/api/dashboard/route.test.ts, tests/lib/db/tasks.test.ts</files>
  <action>
**1. Update `tests/app/api/dashboard/route.test.ts`:**

The mock `mockTasksDB` (line 17) currently has `getUserTasks: vi.fn().mockResolvedValue([])`. The tests call it 3 times for: allTodayTasks, allTasks, tomorrowTasks. After the change, the route calls `getTaskCount` twice (for counts) and `getUserTasks` once (for tomorrow tasks).

Update `mockTasksDB` definition to add `getTaskCount`:
```typescript
const mockTasksDB = {
  getTodayTasks: vi.fn(),
  getUserTasks: vi.fn().mockResolvedValue([]),
  getTaskCount: vi.fn().mockResolvedValue(0),
};
```

**Update the main test** ("should return aggregated dashboard data with absence info", line 54):
- Remove the triple `mockResolvedValueOnce` chain on `getUserTasks`
- Set up `getTaskCount` to return the right values:
  ```typescript
  vi.mocked(mockTasksDB.getTaskCount)
    .mockResolvedValueOnce(1)   // tasks_completed_today (1 completed task for today)
    .mockResolvedValueOnce(3);  // total_tasks (3 total tasks)
  ```
- Set up `getUserTasks` for the single remaining call (tomorrow tasks):
  ```typescript
  vi.mocked(mockTasksDB.getUserTasks)
    .mockResolvedValueOnce(tomorrowTasks as any);
  ```
- Remove `todayDateTasks` and `allTasks` arrays (no longer needed) -- these were only used for the count assertions
- Keep assertions: `data.stats.total_tasks === 3`, `data.stats.tasks_completed_today === 1`

**Update other tests** that mock `getUserTasks`:
- "should compute absence data from bulk logs" (line 110): already uses `.mockResolvedValue([])` for all -- add `getTaskCount` returning 0
- "should handle empty state" (line 138): same pattern
- "should accept a date parameter" (line 154): same pattern
- "should return milestones_today" (line 165): same pattern
- "should call getAllUserLogs" (line 184): same pattern
- "should fetch tomorrow tasks" (line 199): This test asserts `getUserTasks` was called with tomorrow date. After the change, `getUserTasks` is called only once (for tomorrow), so update the assertion from `calls[2]` to `calls[0]`:
  ```typescript
  const calls = vi.mocked(mockTasksDB.getUserTasks).mock.calls;
  expect(calls[0]).toEqual(['user-123', { due_date: '2026-03-01', is_completed: false }]);
  ```
- "should derive Jan 1 for Dec 31" (line 211): same fix -- `calls[2]` becomes `calls[0]`
- "should return dashboard data even when getAllUserLogs fails" (line 232): add `getTaskCount` returning 0
- "should pass client date to getTodaysMilestones" (line 266): add `getTaskCount` returning 0
- "should return dashboard data even when milestones fetch fails" (line 277): add `getTaskCount` returning 0

For tests where `getTaskCount` isn't explicitly set up, the default `.mockResolvedValue(0)` on the mock definition handles it.

**2. Add `getTaskCount` tests to `tests/lib/db/tasks.test.ts`:**

Add a new `describe('getTaskCount', ...)` block after the `getUserTasks` describe block. Tests to add:

```typescript
describe('getTaskCount', () => {
  it('should count all tasks for a user', async () => {
    mockSupabaseClient.setMockResponse(null, null, 5);

    const count = await tasksDB.getTaskCount(mockUserId);

    expect(count).toBe(5);
    expect(mockSupabaseClient.from).toHaveBeenCalledWith('tasks');
    expect(mockSupabaseClient.select).toHaveBeenCalledWith('*', { count: 'exact', head: true });
    expect(mockSupabaseClient.eq).toHaveBeenCalledWith('user_id', mockUserId);
  });

  it('should count with is_completed filter', async () => {
    mockSupabaseClient.setMockResponse(null, null, 3);

    const count = await tasksDB.getTaskCount(mockUserId, { is_completed: true });

    expect(count).toBe(3);
    expect(mockSupabaseClient.eq).toHaveBeenCalledWith('is_completed', true);
  });

  it('should count with due_date filter', async () => {
    mockSupabaseClient.setMockResponse(null, null, 2);

    const count = await tasksDB.getTaskCount(mockUserId, { due_date: '2026-01-31' });

    expect(count).toBe(2);
    expect(mockSupabaseClient.eq).toHaveBeenCalledWith('due_date', '2026-01-31');
  });

  it('should return 0 when count is null', async () => {
    mockSupabaseClient.setMockResponse(null, null, null);

    const count = await tasksDB.getTaskCount(mockUserId);

    expect(count).toBe(0);
  });

  it('should handle database errors', async () => {
    mockSupabaseClient.setMockResponse(null, { message: 'DB error' });

    await expect(tasksDB.getTaskCount(mockUserId)).rejects.toEqual({ message: 'DB error' });
  });
});
```

Note: `mockSupabaseClient.setMockResponse(data, error, count)` already supports the third `count` parameter (see `tests/setup.ts` line 61).
  </action>
  <verify>Run `pnpm test:run tests/lib/db/tasks.test.ts tests/app/api/dashboard/route.test.ts` -- all tests pass. Run `pnpm test:run` for the full suite to confirm no regressions.</verify>
  <done>All existing dashboard tests pass with updated mocks. New `getTaskCount` tests exist and pass. No test regressions in the full suite.</done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds (no type errors from the refactor)
2. `pnpm lint` passes
3. `pnpm test:run` -- full test suite passes
4. Grep confirms no `getUserTasks` calls in dashboard files that are only used for `.length`:
   - `grep -n "getUserTasks" app/api/dashboard/route.ts` should show only the tomorrow-tasks call
   - `grep -n "getUserTasks" app/dashboard/page.tsx` should show only the tomorrow-tasks call
5. `grep -n "getTaskCount" lib/db/tasks.ts` confirms the new method exists
</verification>

<success_criteria>
- `getTaskCount` method exists on TasksDB using `{ count: 'exact', head: true }`
- Dashboard API route uses `getTaskCount` for `total_tasks` and `tasks_completed_today`
- SSR dashboard page uses `getTaskCount` for `total_tasks` and `tasks_completed_today`
- `DashboardData` type is unchanged
- All tests pass including new `getTaskCount` tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance/04-01-SUMMARY.md`
</output>
