---
phase: 04-performance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/habit-logs.ts
  - tests/lib/db/habit-logs.test.ts
autonomous: true

must_haves:
  truths:
    - "A habit with a 5-day streak queries only ~30 days of logs, not 365"
    - "A habit with a streak reaching the 30-day boundary automatically expands to 60 days and retries"
    - "Streak values are identical to the previous 365-day implementation for all frequency types"
    - "The weekly streak calculator (calculateWeeklyStreak) is unchanged internally"
  artifacts:
    - path: "lib/db/habit-logs.ts"
      provides: "calculateStreak with adaptive lookback (30->60->120->240->365)"
      contains: "INITIAL_WINDOW"
  key_links:
    - from: "lib/db/habit-logs.ts calculateStreak"
      to: "lib/db/habit-logs.ts getLogsByDateRange"
      via: "adaptive window loop calling getLogsByDateRange with expanding date ranges"
      pattern: "windowDays.*MAX_WINDOW"
    - from: "lib/db/habit-logs.ts calculateStreak"
      to: "lib/db/habit-logs.ts calculateWeeklyStreak"
      via: "delegation for times_per_week and weekly frequency types"
      pattern: "this\\.calculateWeeklyStreak"
---

<objective>
Refactor calculateStreak to use an adaptive lookback window that starts at 30 days and doubles as needed, instead of always fetching 365 days of logs.

Purpose: A user with a 5-day streak currently triggers a query for 365 days of habit logs. The adaptive approach starts with 30 days (covers most users), and only expands if the streak reaches the window boundary. This reduces data transfer for the common case (short streaks) while preserving correctness for long streaks.

Output: Refactored `calculateStreak` in `lib/db/habit-logs.ts`, updated and new tests.
</objective>

<execution_context>
@/home/xingdi/.claude/get-shit-done/workflows/execute-plan.md
@/home/xingdi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-performance/04-RESEARCH.md

@lib/db/habit-logs.ts
@lib/db/types.ts
@lib/habits/format.ts
@tests/lib/db/habit-logs.test.ts
@tests/setup.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor calculateStreak to use adaptive lookback window</name>
  <files>lib/db/habit-logs.ts</files>
  <action>
Replace the current `calculateStreak` method (lines 159-223) with an adaptive lookback version. The key change is wrapping the log fetch and streak walk in a loop that starts at 30 days and doubles until the streak is definitively resolved or 365 days is reached.

**Constants** (add at the top of the method):
```typescript
const INITIAL_WINDOW = 30;
const MAX_WINDOW = 365;
```

**Algorithm for daily/weekdays/custom frequencies:**

```typescript
async calculateStreak(
  habitId: string,
  userId: string,
  frequency: HabitFrequency,
  previousBestStreak: number = 0,
  weekStartDay: number = 0
): Promise<{ currentStreak: number; bestStreak: number }> {
  const INITIAL_WINDOW = 30;
  const MAX_WINDOW = 365;

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  let windowDays = INITIAL_WINDOW;

  while (true) {
    const startDate = new Date(today);
    startDate.setDate(startDate.getDate() - windowDays);

    const logs = await this.getLogsByDateRange(
      habitId,
      userId,
      getLocalDateString(startDate),
      getLocalDateString(today)
    );

    const completedDates = new Set(
      logs.filter(log => log.completed).map(log => log.logged_date)
    );

    // Weekly-type frequencies: delegate to existing weekly streak calculator
    if (frequency.type === 'times_per_week') {
      const result = this.calculateWeeklyStreak(completedDates, frequency.count, weekStartDay, today, previousBestStreak);
      const weeksInWindow = Math.floor(windowDays / 7);
      if (result.currentStreak < weeksInWindow || windowDays >= MAX_WINDOW) {
        return result;
      }
      windowDays = Math.min(windowDays * 2, MAX_WINDOW);
      continue;
    }
    if (frequency.type === 'weekly') {
      const result = this.calculateWeeklyStreak(completedDates, 1, weekStartDay, today, previousBestStreak);
      const weeksInWindow = Math.floor(windowDays / 7);
      if (result.currentStreak < weeksInWindow || windowDays >= MAX_WINDOW) {
        return result;
      }
      windowDays = Math.min(windowDays * 2, MAX_WINDOW);
      continue;
    }

    // Daily/weekdays/custom: walk backward counting consecutive completions
    let currentStreak = 0;
    const checkDate = new Date(today);
    let hitBoundary = false;

    while (true) {
      const dateStr = getLocalDateString(checkDate);

      // Check if we've walked past the start of our query window
      if (checkDate < startDate) {
        hitBoundary = true;
        break;
      }

      if (shouldTrackOnDate(frequency, checkDate)) {
        if (completedDates.has(dateStr)) {
          currentStreak++;
        } else {
          // Allow today to be incomplete without breaking streak
          if (dateStr !== getLocalDateString(today)) {
            break; // Streak broken -- definitive result
          }
        }
      }

      checkDate.setDate(checkDate.getDate() - 1);
    }

    if (!hitBoundary || windowDays >= MAX_WINDOW) {
      const bestStreak = Math.max(currentStreak, previousBestStreak);
      return { currentStreak, bestStreak };
    }

    // Streak extends to window boundary -- expand and retry
    windowDays = Math.min(windowDays * 2, MAX_WINDOW);
  }
}
```

**Key behavioral requirements:**
1. `calculateWeeklyStreak` is NOT modified -- it stays exactly as-is. Only the data-fetch layer around it changes.
2. The boundary detection for weekly streaks uses `result.currentStreak < weeksInWindow` -- if the streak fills the available weeks, we need more data.
3. The boundary detection for daily streaks uses `checkDate < startDate` -- if the walker runs out of fetched data before finding a break.
4. Today is still allowed to be incomplete without breaking the streak (preserving existing behavior).
5. The doubling pattern is 30 -> 60 -> 120 -> 240 -> 365 (capped).
6. Remove the old safety limit comment (`// Safety limit` and the 365-day time check) -- the adaptive window loop replaces it.
  </action>
  <verify>Run `pnpm lint` to confirm no type errors. Run `pnpm test:run tests/lib/db/habit-logs.test.ts` to confirm existing streak tests still pass.</verify>
  <done>calculateStreak uses adaptive lookback starting at 30 days. Existing tests pass unchanged (proving behavioral equivalence for short streaks).</done>
</task>

<task type="auto">
  <name>Task 2: Add tests verifying adaptive lookback behavior</name>
  <files>tests/lib/db/habit-logs.test.ts</files>
  <action>
Add a new `describe('calculateStreak adaptive lookback', ...)` block inside the existing `HabitLogsDB` describe. These tests verify the adaptive behavior -- that short streaks use small windows and long streaks expand.

The test approach: since `getLogsByDateRange` is the Supabase query method, spy on it and check what date ranges it's called with. For unit tests using `mockSupabaseClient`, we can track calls to verify the window size.

**However**, the existing tests use `mockSupabaseClient` which is a global mock. The `calculateStreak` method calls `this.getLogsByDateRange` which chains Supabase queries. The simplest approach: use `vi.spyOn` on the `habitLogsDB` instance to mock `getLogsByDateRange` directly, bypassing Supabase.

Add these tests:

```typescript
describe('calculateStreak adaptive lookback', () => {
  it('should query only ~30 days for a short streak (not 365)', async () => {
    // Spy on getLogsByDateRange to track date ranges
    const spy = vi.spyOn(habitLogsDB, 'getLogsByDateRange');

    // Return logs for a 5-day streak (no boundary hit)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const logs = [];
    for (let i = 0; i < 5; i++) {
      const d = new Date(today);
      d.setDate(d.getDate() - i);
      logs.push({
        id: `log-${i}`, habit_id: 'h1', user_id: 'u1',
        logged_date: getLocalDateString(d), completed: true,
        created_at: '', updated_at: '',
      });
    }
    spy.mockResolvedValueOnce(logs as any);

    const result = await habitLogsDB.calculateStreak(
      'h1', 'u1', { type: 'daily' }, 0
    );

    expect(result.currentStreak).toBe(5);
    // Should have been called exactly once (30-day window sufficient)
    expect(spy).toHaveBeenCalledTimes(1);
    // Verify the date range is ~30 days, not 365
    const [, , startDate] = spy.mock.calls[0];
    const start = new Date(startDate);
    const diffDays = Math.round((today.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
    expect(diffDays).toBe(30);

    spy.mockRestore();
  });

  it('should expand window when streak reaches boundary', async () => {
    const spy = vi.spyOn(habitLogsDB, 'getLogsByDateRange');

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // First call (30-day window): return 30 consecutive completed days
    // This fills the entire window, triggering expansion
    const logs30 = [];
    for (let i = 0; i < 31; i++) {
      const d = new Date(today);
      d.setDate(d.getDate() - i);
      logs30.push({
        id: `log-${i}`, habit_id: 'h1', user_id: 'u1',
        logged_date: getLocalDateString(d), completed: true,
        created_at: '', updated_at: '',
      });
    }

    // Second call (60-day window): return 35 days then a gap
    // Streak = 35, window = 60, so streak < 60 => definitive
    const logs60 = [];
    for (let i = 0; i < 35; i++) {
      const d = new Date(today);
      d.setDate(d.getDate() - i);
      logs60.push({
        id: `log-${i}`, habit_id: 'h1', user_id: 'u1',
        logged_date: getLocalDateString(d), completed: true,
        created_at: '', updated_at: '',
      });
    }

    spy.mockResolvedValueOnce(logs30 as any);
    spy.mockResolvedValueOnce(logs60 as any);

    const result = await habitLogsDB.calculateStreak(
      'h1', 'u1', { type: 'daily' }, 0
    );

    expect(result.currentStreak).toBe(35);
    // Should have been called twice (30-day window was insufficient)
    expect(spy).toHaveBeenCalledTimes(2);

    // Verify second call used 60-day window
    const [, , startDate60] = spy.mock.calls[1];
    const start60 = new Date(startDate60);
    const diffDays60 = Math.round((today.getTime() - start60.getTime()) / (1000 * 60 * 60 * 24));
    expect(diffDays60).toBe(60);

    spy.mockRestore();
  });

  it('should cap at 365 days maximum', async () => {
    const spy = vi.spyOn(habitLogsDB, 'getLogsByDateRange');

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Return all-completed logs for every window size to force maximum expansion
    // 30 -> 60 -> 120 -> 240 -> 365 = 5 calls
    for (let w = 0; w < 5; w++) {
      const windowSize = Math.min(30 * Math.pow(2, w), 365);
      const logs = [];
      for (let i = 0; i <= windowSize; i++) {
        const d = new Date(today);
        d.setDate(d.getDate() - i);
        logs.push({
          id: `log-${w}-${i}`, habit_id: 'h1', user_id: 'u1',
          logged_date: getLocalDateString(d), completed: true,
          created_at: '', updated_at: '',
        });
      }
      spy.mockResolvedValueOnce(logs as any);
    }

    const result = await habitLogsDB.calculateStreak(
      'h1', 'u1', { type: 'daily' }, 0
    );

    // With all days completed up to 365, streak should be 365 or close
    expect(result.currentStreak).toBeGreaterThan(200);
    // The last call should use a 365-day window
    const lastCall = spy.mock.calls[spy.mock.calls.length - 1];
    const [, , lastStartDate] = lastCall;
    const lastStart = new Date(lastStartDate);
    const diffDays = Math.round((today.getTime() - lastStart.getTime()) / (1000 * 60 * 60 * 24));
    expect(diffDays).toBe(365);

    spy.mockRestore();
  });
});
```

Import `getLocalDateString` at the top of the test file if not already imported:
```typescript
import { getLocalDateString } from '@/lib/utils';
```

Also import `habitLogsDB` if not already imported (it should be, since the existing tests use it).
  </action>
  <verify>Run `pnpm test:run tests/lib/db/habit-logs.test.ts` -- all tests pass including the new adaptive lookback tests. Run `pnpm test:run` for the full suite to confirm no regressions. Run `pnpm lint` to confirm no lint errors.</verify>
  <done>New tests prove: (1) short streaks use only one 30-day query, (2) boundary-hitting streaks trigger window expansion, (3) maximum window is capped at 365 days. All existing streak tests continue to pass.</done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds
2. `pnpm lint` passes
3. `pnpm test:run tests/lib/db/habit-logs.test.ts` -- all tests pass (existing + new)
4. `pnpm test:run` -- full suite passes
5. Grep for `365` in `calculateStreak` confirms it appears only as `MAX_WINDOW` constant, not as a hardcoded fetch range
6. Grep for `INITIAL_WINDOW` confirms the 30-day starting window is in place
</verification>

<success_criteria>
- calculateStreak starts with a 30-day lookback window (INITIAL_WINDOW = 30)
- Window doubles (30 -> 60 -> 120 -> 240 -> 365) when streak reaches boundary
- Maximum window is capped at 365 days (MAX_WINDOW = 365)
- calculateWeeklyStreak is unchanged internally
- A 5-day streak triggers only 1 query (30-day window)
- All existing streak tests pass (behavioral equivalence)
- New tests verify adaptive behavior
</success_criteria>

<output>
After completion, create `.planning/phases/04-performance/04-02-SUMMARY.md`
</output>
