---
phase: 01-frequency-correctness
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/db/insights.ts
  - components/dashboard/weekly-insight-card.tsx
  - tests/lib/db/insights.test.ts
  - tests/components/dashboard/weekly-insight-card.test.tsx
  - tests/app/api/insights/weekly.test.ts
autonomous: true

must_haves:
  truths:
    - "WeeklyInsight type is a discriminated union keyed on the type field with typed params for each variant"
    - "Only one WeeklyInsight type definition exists in the codebase (in lib/db/insights.ts)"
    - "weekly-insight-card.tsx imports WeeklyInsight from lib/db/insights.ts, not defines its own"
    - "TypeScript compiles without errors when accessing typed params (e.g., insight.params.habit for best_habit)"
  artifacts:
    - path: "lib/db/insights.ts"
      provides: "Discriminated union WeeklyInsight type with typed params per variant"
      exports: ["WeeklyInsight", "InsightsDB"]
    - path: "components/dashboard/weekly-insight-card.tsx"
      provides: "Component importing WeeklyInsight from lib/db/insights.ts"
  key_links:
    - from: "components/dashboard/weekly-insight-card.tsx"
      to: "lib/db/insights.ts"
      via: "import { WeeklyInsight }"
      pattern: "import.*WeeklyInsight.*from.*lib/db/insights"
    - from: "tests/components/dashboard/weekly-insight-card.test.tsx"
      to: "lib/db/insights.ts"
      via: "import { WeeklyInsight }"
      pattern: "import.*WeeklyInsight.*from.*lib/db/insights"
---

<objective>
Replace the flat `params: Record<string, string | number>` on WeeklyInsight with a discriminated union keyed on the `type` field, and remove the duplicate type definition from weekly-insight-card.tsx.

Purpose: Enables exhaustive `switch` statements and compile-time type safety when consuming different insight types, preventing runtime errors from accessing wrong param fields. Consolidates the type to a single source of truth.

Output: Single discriminated union type in `lib/db/insights.ts`, all consumers updated, all tests pass.
</objective>

<execution_context>
@/home/xingdi/.claude/get-shit-done/workflows/execute-plan.md
@/home/xingdi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-frequency-correctness/01-CONTEXT.md
@.planning/phases/01-frequency-correctness/01-RESEARCH.md
@.planning/phases/01-frequency-correctness/01-01-SUMMARY.md
@lib/db/insights.ts
@components/dashboard/weekly-insight-card.tsx
@tests/lib/db/insights.test.ts
@tests/components/dashboard/weekly-insight-card.test.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define discriminated union WeeklyInsight type and remove duplicate</name>
  <files>
    lib/db/insights.ts
    components/dashboard/weekly-insight-card.tsx
  </files>
  <action>
**1. Replace `WeeklyInsight` in `lib/db/insights.ts` (lines 7-18):**

Replace the current interface:
```typescript
export interface WeeklyInsight {
  type: "best_week" | "worst_day" | "best_habit" | "streak_proximity" | "improvement" | "decline";
  message: string;
  params: Record<string, string | number>;
  priority: number;
}
```

With a discriminated union (verified param shapes from source code):
```typescript
type WeeklyInsightBase = {
  message: string;
  priority: number;
};

export type WeeklyInsight = WeeklyInsightBase & (
  | { type: "best_week"; params: { percent: number } }
  | { type: "worst_day"; params: { day: string } }
  | { type: "best_habit"; params: { habit: string; percent: number } }
  | { type: "streak_proximity"; params: { habit: string; days: number; milestone: number } }
  | { type: "improvement"; params: { change: number } }
  | { type: "decline"; params: { percent: number; lastPercent: number } }
);
```

**2. Update `weekly-insight-card.tsx` to import from `lib/db/insights.ts`:**

Remove the local `WeeklyInsight` interface definition (lines 8-13):
```typescript
// DELETE this:
export interface WeeklyInsight {
  type: string;
  message: string;
  params: Record<string, string | number>;
  priority: number;
}
```

Add import at the top:
```typescript
import type { WeeklyInsight } from "@/lib/db/insights";
```

Keep the `export` on the component but remove the export from the deleted interface. If the component currently re-exports `WeeklyInsight`, ensure consumers can still import it (they should import from `lib/db/insights.ts` instead).

**3. Verify the `getWeeklyInsights` method in `insights.ts` still compiles:**
The method pushes objects with literal `type` and `params` fields. TypeScript should infer the correct variant from the literal `type` string. If the compiler complains about object literal types, add `as const` to the type field or use explicit typing:
```typescript
candidates.push({
  type: "streak_proximity" as const,
  message: "streakProximity",
  params: { habit: (habit as Habit).name, days: daysToMilestone, milestone },
  priority: 100,
});
```

The `candidates` array should be typed as `WeeklyInsight[]`. Since each push uses a literal `type` value, TypeScript should narrow correctly. If not, type `candidates` explicitly or use satisfies.

**4. Update the `topInsight.params` access in `weekly-insight-card.tsx`:**
The component currently accesses `topInsight.params` generically via `t(topInsight.message, topInsight.params)`. The `next-intl` `t()` function accepts `Record<string, string | number | ...>` for params. Since the component doesn't destructure specific params fields (it passes the whole object to `t()`), the existing code should still work. However, `topInsight.params` is now a union type, not `Record<string, string | number>`. If TypeScript complains, cast: `topInsight.params as Record<string, string | number>` in the `t()` call, or use a type assertion. Alternatively, since `t()` from next-intl accepts `Record<string, unknown>`, it should work without changes.
  </action>
  <verify>
Run `pnpm lint` to confirm TypeScript compilation and no lint errors.

Run `pnpm test:run -- tests/lib/db/insights.test.ts tests/components/dashboard/weekly-insight-card.test.tsx tests/app/api/insights/weekly.test.ts` -- all tests must pass.

Grep to confirm single definition: `grep -rn "interface WeeklyInsight\|type WeeklyInsight" lib/ components/` should show only one definition in `lib/db/insights.ts`.
  </verify>
  <done>
- `WeeklyInsight` is a discriminated union with typed params per variant in `lib/db/insights.ts`
- No `WeeklyInsight` interface/type exists in `components/dashboard/weekly-insight-card.tsx`
- `weekly-insight-card.tsx` imports `WeeklyInsight` from `lib/db/insights`
- TypeScript compiles without errors
- All insight-related tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Update test files to use the new WeeklyInsight type</name>
  <files>
    tests/components/dashboard/weekly-insight-card.test.tsx
    tests/lib/db/insights.test.ts
    tests/app/api/insights/weekly.test.ts
  </files>
  <action>
**1. Update `tests/components/dashboard/weekly-insight-card.test.tsx`:**

Change the import from:
```typescript
import { WeeklyInsightCard, type WeeklyInsight } from "@/components/dashboard/weekly-insight-card";
```
To:
```typescript
import { WeeklyInsightCard } from "@/components/dashboard/weekly-insight-card";
import type { WeeklyInsight } from "@/lib/db/insights";
```

Verify all test data objects match the discriminated union. Current test data already uses correct shapes:
- `{ type: "best_habit", params: { habit: "Meditate", percent: 100 } }` -- matches
- `{ type: "streak_proximity", params: { habit: "Running", days: 2, milestone: 30 } }` -- matches
- `{ type: "improvement", params: { change: 15 } }` -- matches

These should compile without changes since the data already matches the typed params.

**2. Update `tests/lib/db/insights.test.ts`:**

No import changes needed (tests create data that gets returned through the mock Supabase chain; they don't directly construct `WeeklyInsight` objects). The test assertions access `.params.habit`, `.params.days`, `.params.milestone`, `.params.percent`, `.params.change`, `.params.lastPercent` -- these all match the discriminated union's typed params. No changes needed unless TypeScript complains about assertion types.

**3. Check `tests/app/api/insights/weekly.test.ts`:**

Read this file and update any mock `WeeklyInsight` objects to match the new discriminated union if needed. If mocks use `Record<string, string | number>` params, update to match the specific variant's param shape.
  </action>
  <verify>
Run `pnpm test:run` -- ALL tests must pass (full suite, not just insight tests, to catch any regression).

Run `pnpm lint` -- no TypeScript or ESLint errors.

Run `pnpm build` -- production build succeeds.
  </verify>
  <done>
- `weekly-insight-card.test.tsx` imports `WeeklyInsight` from `lib/db/insights` (not from component)
- All test data objects match the discriminated union param shapes
- `pnpm test:run` passes all tests
- `pnpm lint` passes
- `pnpm build` succeeds
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Single type source:** `grep -rn "WeeklyInsight" lib/ components/ tests/` shows definition only in `lib/db/insights.ts`, imports elsewhere
2. **No duplicate definition:** `grep -rn "interface WeeklyInsight" components/` returns 0 results
3. **Discriminated union works:** The type in `lib/db/insights.ts` uses intersection with union (`& (| { type: "best_week"; ... } | ...)`)
4. **All tests pass:** `pnpm test:run` with 0 failures
5. **Lint clean:** `pnpm lint` with 0 errors
6. **Build succeeds:** `pnpm build` completes without errors
</verification>

<success_criteria>
1. `WeeklyInsight` type is a discriminated union with 6 variants, each with typed params
2. Only one `WeeklyInsight` definition exists in the codebase (in `lib/db/insights.ts`)
3. `weekly-insight-card.tsx` imports the type from `lib/db/insights.ts`
4. All existing tests pass without modification to test logic (only import paths change)
5. TypeScript provides compile-time errors if wrong param fields are accessed for a given insight type
6. `pnpm test:run`, `pnpm lint`, and `pnpm build` all succeed
</success_criteria>

<output>
After completion, create `.planning/phases/01-frequency-correctness/01-02-SUMMARY.md`
</output>
