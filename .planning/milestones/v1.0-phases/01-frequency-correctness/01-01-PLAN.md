---
phase: 01-frequency-correctness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/habits/format.ts
  - lib/db/habit-logs.ts
  - lib/db/habits.ts
  - lib/db/insights.ts
  - lib/habits/absence.ts
  - lib/habits/heatmap.ts
  - tests/lib/habits/format.test.ts
  - tests/lib/habits/heatmap.test.ts
  - tests/lib/habits/absence.test.ts
  - tests/lib/db/habit-logs.test.ts
autonomous: true

must_haves:
  truths:
    - "shouldTrackOnDate returns true for all days when frequency is weekly (not just Monday)"
    - "Only one copy of shouldTrackOnDate exists in the codebase (in lib/habits/format.ts)"
    - "calculateStreak for weekly habits counts consecutive successful weeks (not consecutive days)"
    - "getDetailedHabitStats for weekly habits evaluates at the week level (1 completion = 100% for that week)"
    - "getScheduledDays for weekly habits counts weeks, not individual days"
    - "computePerHabitRates for weekly habits uses week-level evaluation"
    - "computeMissedDays for weekly/times_per_week evaluates at week level"
    - "All tests pass including updated assertions for correct frequency behavior"
  artifacts:
    - path: "lib/habits/format.ts"
      provides: "Canonical shouldTrackOnDate with weekly returning true for all days"
      contains: "case \"weekly\""
    - path: "lib/db/habit-logs.ts"
      provides: "Streak and stats calculations with weekly-aware logic, no duplicate shouldTrackOnDate"
      exports: ["HabitLogsDB"]
    - path: "lib/db/habits.ts"
      provides: "getScheduledDays with week-level counting for weekly frequency"
    - path: "lib/db/insights.ts"
      provides: "computePerHabitRates and computePerDayRates with weekly-aware evaluation"
    - path: "lib/habits/absence.ts"
      provides: "computeMissedDays with week-level evaluation for weekly/times_per_week"
    - path: "lib/habits/heatmap.ts"
      provides: "buildHeatmapData using shouldTrackOnDate (weekly now returns true for all days)"
  key_links:
    - from: "lib/db/habit-logs.ts"
      to: "lib/habits/format.ts"
      via: "import { shouldTrackOnDate }"
      pattern: "import.*shouldTrackOnDate.*from.*habits/format"
    - from: "lib/db/habit-logs.ts calculateStreak"
      to: "lib/db/habit-logs.ts calculateWeeklyStreak"
      via: "Route weekly frequency to calculateWeeklyStreak with targetPerWeek=1"
      pattern: "frequency\\.type.*weekly.*calculateWeeklyStreak"
    - from: "lib/db/insights.ts computePerHabitRates"
      to: "lib/habits/format.ts shouldTrackOnDate"
      via: "Week-level evaluation when frequency is weekly or times_per_week"
      pattern: "shouldTrackOnDate|weekly|times_per_week"
---

<objective>
Fix shouldTrackOnDate for weekly frequency, deduplicate the function, and update all 6 consumer modules to use correct week-level evaluation for weekly and times_per_week habits. Update all tests asserting incorrect behavior.

Purpose: Users currently see wrong completion percentages and streaks for weekly habits (hardcoded to Monday only) and times_per_week habits (day-level evaluation inflates/deflates rates). After this plan, all frequency calculations are correct per PRD V1.2 section 6.2.

Output: Corrected calculation logic across 6 source files and 4 test files. All tests pass with correct assertions.
</objective>

<execution_context>
@/home/xingdi/.claude/get-shit-done/workflows/execute-plan.md
@/home/xingdi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-frequency-correctness/01-CONTEXT.md
@.planning/phases/01-frequency-correctness/01-RESEARCH.md
@lib/habits/format.ts
@lib/db/habit-logs.ts
@lib/db/habits.ts
@lib/db/insights.ts
@lib/habits/absence.ts
@lib/habits/heatmap.ts
@lib/db/types.ts
@tests/lib/habits/format.test.ts
@tests/lib/habits/heatmap.test.ts
@tests/lib/habits/absence.test.ts
@tests/lib/db/habit-logs.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix shouldTrackOnDate, deduplicate, and update all consumer modules</name>
  <files>
    lib/habits/format.ts
    lib/db/habit-logs.ts
    lib/db/habits.ts
    lib/db/insights.ts
    lib/habits/absence.ts
    lib/habits/heatmap.ts
  </files>
  <action>
**1. Fix `shouldTrackOnDate` in `lib/habits/format.ts` (line 87):**
Change the `weekly` case from `return dayOfWeek === 1` to `return true`. Per user decision: "any day that week counts" -- not hardcoded to Monday. The `times_per_week` case already returns `true` (correct, leave it).

**2. Remove duplicate `shouldTrackOnDate` from `lib/db/habit-logs.ts` (lines 295-321):**
- Add `import { shouldTrackOnDate } from '@/lib/habits/format';` at the top of `habit-logs.ts`
- Delete the `private shouldTrackOnDate` method (lines 295-321)
- Replace `this.shouldTrackOnDate(...)` calls on line 201 and line 424 with `shouldTrackOnDate(...)` (remove `this.`)

**3. Route `weekly` to `calculateWeeklyStreak` in `lib/db/habit-logs.ts`:**
In the `calculateStreak` method (~line 189), add `weekly` to the special-case routing alongside `times_per_week`:
```typescript
if (frequency.type === 'times_per_week') {
  return this.calculateWeeklyStreak(completedDates, frequency.count, weekStartDay, today, previousBestStreak);
}
if (frequency.type === 'weekly') {
  return this.calculateWeeklyStreak(completedDates, 1, weekStartDay, today, previousBestStreak);
}
```
This reuses the existing `calculateWeeklyStreak` with `targetPerWeek = 1`. Without this, `calculateStreak` would walk day-by-day expecting a completion every day for weekly habits (broken).

**4. Update `getDetailedHabitStats` in `lib/db/habit-logs.ts` to handle `weekly` like `times_per_week`:**
The method already has a special branch for `times_per_week` (line 402) that uses `getTimesPerWeekStats`. Add `weekly` to this branch:
```typescript
if (frequency.type === 'times_per_week' || frequency.type === 'weekly') {
  const targetPerWeek = frequency.type === 'times_per_week' ? frequency.count : 1;
  // ... fetch completedLogs (existing code) ...
  return this.getTimesPerWeekStats(completedDates, targetPerWeek, weekStartDay, today, startOfWeek, startOfMonth, habitCreatedAt);
}
```
Without this, the `countDaysInRange` fallback would count 7 scheduled days per week for `weekly`, giving 1/7 = 14% for a habit completed once that week.

**5. Update `getScheduledDays` in `lib/db/habits.ts` (~line 196):**
Add a `weekly` case alongside the existing `times_per_week` case:
```typescript
if (frequency.type === 'times_per_week' || frequency.type === 'weekly') {
  const targetPerWeek = frequency.type === 'times_per_week' ? frequency.count : 1;
  // Count weeks in the month, multiply by target
  const [y, m, d] = today.split('-').map(Number);
  const start = new Date(y, m - 1, 1);
  const end = new Date(y, m - 1, d);
  let weeks = 0;
  const cursor = new Date(start);
  while (cursor <= end) {
    if (cursor.getDay() === 1) weeks++; // count Mondays as week markers
    cursor.setDate(cursor.getDate() + 1);
  }
  const scheduled = Math.max(weeks, 1) * targetPerWeek;
  scheduledDaysCache.set(key, scheduled);
  return scheduled;
}
```
Without this, `shouldTrackOnDate` returning `true` for weekly would count ~30 scheduled days/month, massively deflating the monthly completion rate.

**6. Update `computePerHabitRates` in `lib/db/insights.ts` (~line 226):**
For `weekly` and `times_per_week` habits, switch from day-level to week-level evaluation. After the existing day-by-day loop for regular habits, add special handling:
```typescript
for (const habit of habits) {
  if (habit.frequency.type === 'weekly' || habit.frequency.type === 'times_per_week') {
    const targetPerWeek = habit.frequency.type === 'times_per_week' ? habit.frequency.count : 1;
    const habitLogs = logsByHabit.get(habit.id) || new Set<string>();
    // Count completions in this week period
    const completions = habitLogs.size;
    // For a single week, rate = did they meet the target?
    const rate = completions >= targetPerWeek ? 100 : Math.round((completions / targetPerWeek) * 100);
    rates.set(habit.id, rate);
    continue; // Skip the day-by-day loop below
  }
  // ... existing day-by-day logic for other frequency types ...
}
```

**7. Update `computePerDayRates` in `lib/db/insights.ts` (~line 265):**
Skip `weekly` and `times_per_week` habits in the per-day rate calculation, since "worst day of week" is not meaningful for habits where any day counts. Add an early continue:
```typescript
for (const habit of habits) {
  if (habit.frequency.type === 'weekly' || habit.frequency.type === 'times_per_week') {
    continue; // Per-day rates not meaningful for week-level habits
  }
  if (shouldTrackOnDate(habit.frequency, checkDate)) {
    // ... existing logic
  }
}
```

**8. Update `computeMissedDays` in `lib/habits/absence.ts`:**
For `weekly` and `times_per_week` frequencies, the current day-by-day backward walk is incorrect because `shouldTrackOnDate` now returns `true` for every day. Keep the existing day-level logic (it still works for `weekly` with `shouldTrackOnDate` returning `true`) but understand the trade-off: for `weekly`, "3 missed scheduled days" means "3 days since last completion" not "3 missed weeks". This is acceptable per the research recommendation to keep day-level granularity for absence count. No code change needed here -- the existing logic works correctly with the new `shouldTrackOnDate` behavior since it counts consecutive days without completion, which is useful for showing "you haven't done this in X days".

**9. Heatmap (`lib/habits/heatmap.ts`):**
No code change needed. After fixing `shouldTrackOnDate` to return `true` for `weekly`, the heatmap will show all days as trackable for weekly habits. Days without completion show as "missed", days with completion show as "completed". This is acceptable behavior per research -- it shows which day the user actually completed the habit.

**Key design decisions (Claude's discretion per user):**
- `shouldTrackOnDate` for `weekly` returns `true` for all days (simplest approach, consistent with times_per_week)
- Callers that need week-level evaluation (stats, insights, getScheduledDays) handle it in their own logic
- `computeMissedDays` keeps day-level granularity (counts days since last completion, useful for absence indicators)
- Heatmap uses `shouldTrackOnDate` directly (weekly shows all days as trackable)
  </action>
  <verify>
Run `pnpm test:run -- tests/lib/habits/format.test.ts tests/lib/habits/heatmap.test.ts tests/lib/habits/absence.test.ts tests/lib/db/habit-logs.test.ts tests/lib/db/insights.test.ts tests/lib/db/habits.test.ts` -- expect some tests to FAIL because they still assert the OLD (incorrect) behavior. This confirms the logic changes are working. Note which tests fail -- they should be the 8 tests identified in the research.

Also run `pnpm lint` to ensure no TypeScript/ESLint errors.

Grep the codebase to confirm deduplication: `grep -rn "shouldTrackOnDate" lib/` should show only ONE definition (in format.ts) and imports in other files, never a `private shouldTrackOnDate` method.
  </verify>
  <done>
- `shouldTrackOnDate` in `lib/habits/format.ts` returns `true` for weekly (not `dayOfWeek === 1`)
- No `private shouldTrackOnDate` method exists in `lib/db/habit-logs.ts`
- `habit-logs.ts` imports `shouldTrackOnDate` from `lib/habits/format`
- `calculateStreak` routes `weekly` to `calculateWeeklyStreak` with targetPerWeek=1
- `getDetailedHabitStats` routes `weekly` to `getTimesPerWeekStats` with targetPerWeek=1
- `getScheduledDays` counts weeks for `weekly` frequency (not individual days)
- `computePerHabitRates` uses week-level evaluation for weekly/times_per_week
- `computePerDayRates` skips weekly/times_per_week habits
- No TypeScript compilation errors, no ESLint errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update all tests to assert correct frequency behavior</name>
  <files>
    tests/lib/habits/format.test.ts
    tests/lib/habits/heatmap.test.ts
    tests/lib/habits/absence.test.ts
    tests/lib/db/habit-logs.test.ts
  </files>
  <action>
Update tests that assert incorrect (buggy) behavior to assert the correct behavior. Reference the research section "Complete List of Tests Asserting Incorrect Behavior" for the full list.

**1. `tests/lib/habits/format.test.ts` line 117 -- "weekly tracks only Monday":**
Rename to "weekly tracks every day (any day that week counts)" and update assertions:
```typescript
it('weekly tracks every day (any day that week counts)', () => {
  expect(shouldTrackOnDate({ type: 'weekly' }, monday)).toBe(true);
  expect(shouldTrackOnDate({ type: 'weekly' }, tuesday)).toBe(true);
  expect(shouldTrackOnDate({ type: 'weekly' }, sunday)).toBe(true);
});
```

**2. `tests/lib/habits/format.test.ts` line 123 -- "times_per_week tracks every day":**
This test is already correct (asserts `true` for all days). Just verify it still passes. No change needed.

**3. `tests/lib/habits/heatmap.test.ts` line 119 -- "handles weekly frequency: only Monday is scheduled":**
Rename to "handles weekly frequency: all days are scheduled (any day counts)" and update:
```typescript
it('handles weekly frequency: all days are scheduled (any day counts)', () => {
  const weeklyFrequency: HabitFrequency = { type: 'weekly' };
  const cells = buildHeatmapData([], weeklyFrequency);
  // 2026-02-02 is Monday -> scheduled (missed), 2026-02-03 is Tuesday -> also scheduled (missed)
  const mondayCell = cells.find(c => c.date === '2026-02-02');
  expect(mondayCell?.status).toBe('missed');
  const tuesdayCell = cells.find(c => c.date === '2026-02-03');
  expect(tuesdayCell?.status).toBe('missed'); // Was 'not_scheduled', now 'missed' because weekly tracks all days
});
```

**4. `tests/lib/habits/heatmap.test.ts` line 129 -- "handles times_per_week frequency: all days are scheduled":**
Already correct -- asserts all days are scheduled (missed). No change needed.

**5. `tests/lib/habits/absence.test.ts` line 116 -- "handles weekly frequency (Monday only)":**
Rename to "handles weekly frequency (any day counts)" and update assertions:
```typescript
it('handles weekly frequency (any day counts)', () => {
  const weekly: HabitFrequency = { type: 'weekly' };
  // Today is 2026-02-09 (Mon). Walking back from yesterday:
  // Feb 8 (Sun) - tracked (shouldTrackOnDate returns true), not completed -> missed
  // Feb 7 (Sat) - tracked, not completed -> missed
  // Feb 6 (Fri) - tracked, not completed -> missed
  // Feb 5 (Thu) - tracked, not completed -> missed
  // Feb 4 (Wed) - tracked, not completed -> missed
  // Feb 3 (Tue) - tracked, not completed -> missed
  // Feb 2 (Mon) - tracked, completed -> previous_streak starts
  const completed = new Set(['2026-02-02']);
  const result = computeMissedDays(weekly, completed, '2026-02-09', '2026-01-01');

  expect(result.missed_scheduled_days).toBe(6); // 6 days missed (Feb 3-8), not 0
  expect(result.previous_streak).toBe(1);
});
```

**6. `tests/lib/habits/absence.test.ts` line 131 -- "counts missed weeks for weekly frequency":**
Rename to "counts missed days for weekly frequency (day-level granularity)" and update:
```typescript
it('counts missed days for weekly frequency (day-level granularity)', () => {
  const weekly: HabitFrequency = { type: 'weekly' };
  // Today is 2026-02-09 (Mon). Jan 26 was completed, Jan 19 was completed.
  // Walking back from Feb 8: Feb 8,7,6,5,4,3,2,1, Jan 31, Jan 30, Jan 29, Jan 28, Jan 27 = 13 missed days
  // Then Jan 26 completed -> previous_streak starts
  // Jan 25,24,23,22,21,20 not completed -> previous_streak = 1
  // Wait, Jan 19 completed too -> need to trace carefully.
  // Feb 8 (Sun) not completed -> missed
  // ... down to Jan 27 (Tue) not completed -> missed = 13 days (Feb 8 to Jan 27)
  // Jan 26 (Mon) completed -> previous_streak = 1
  // Jan 25 (Sun) not completed -> break (previous_streak stops)
  // Wait: Jan 19 is also completed. Let me re-check.
  // Phase: counting_missed. Feb 8 -> Jan 27: all not completed = 13 missed
  // Phase switches to counting_streak at Jan 26 (completed). previous_streak = 1
  // Jan 25 (Sun) not completed -> break.
  // So: missed=13, previous_streak=1
  // But wait, that doesn't account for Jan 19. Let me re-check the algorithm.
  // computeMissedDays walks backwards: counting_missed until first completion, then counting_streak until first miss.
  // Jan 25 is not in completedDates and shouldTrackOnDate returns true -> break.
  // previous_streak stays at 1.
  const completed = new Set(['2026-01-26', '2026-01-19']);
  const result = computeMissedDays(weekly, completed, '2026-02-09', '2026-01-01');

  expect(result.missed_scheduled_days).toBe(13); // 13 consecutive days missed (Jan 27 - Feb 8)
  expect(result.previous_streak).toBe(1); // Only Jan 26 before the gap in Jan 25
});
```

**7. `tests/lib/habits/absence.test.ts` line 143 -- "treats every day as scheduled for times_per_week frequency":**
This test is already correct -- it asserts day-level counting with `shouldTrackOnDate` returning `true`. No change needed.

**8. `tests/lib/db/habit-logs.test.ts` -- 2 pre-existing failures (issue #98):**
These tests currently PASS because they assert the buggy behavior. The existing `times_per_week` tests in `habit-logs.test.ts` (lines 285-431) already assert correct weekly-group behavior and should continue to pass. If any tests break due to the `weekly` routing change (e.g., `getDetailedHabitStats` now routes `weekly` to `getTimesPerWeekStats`), add a new test for `weekly` frequency in `getDetailedHabitStats`:

```typescript
describe('weekly frequency handling', () => {
  const weeklyFrequency = { type: 'weekly' as const };
  const createdAt = '2026-01-01T00:00:00Z';

  describe('getDetailedHabitStats', () => {
    it('should use week-level evaluation (1 completion = 100% for that week)', async () => {
      // 1 completion this week for a weekly habit
      mockSupabaseClient.setMockResponse([
        { ...mockLog, logged_date: weekDate(2), completed: true },
      ]);

      const stats = await habitLogsDB.getDetailedHabitStats(
        mockHabitId,
        mockUserId,
        weeklyFrequency,
        createdAt,
        0,
      );

      expect(stats.thisWeek.completed).toBe(1);
      expect(stats.thisWeek.total).toBe(1); // target is 1 for weekly
      expect(stats.thisWeek.percent).toBe(100); // 1/1 = 100%
    });
  });

  describe('calculateStreak', () => {
    it('should count consecutive successful weeks for weekly habits', async () => {
      // Use the same prevWeekDate helper pattern from times_per_week tests
      // 2 consecutive weeks with at least 1 completion each
      mockSupabaseClient.setMockResponse([
        { ...mockLog, logged_date: prevWeekDate(1, 3), completed: true },
        { ...mockLog, logged_date: weekDate(1), completed: true },
      ]);

      const result = await habitLogsDB.calculateStreak(
        mockHabitId,
        mockUserId,
        weeklyFrequency,
        0,
        0,
      );

      expect(result.currentStreak).toBeGreaterThanOrEqual(1);
      expect(result.bestStreak).toBeGreaterThanOrEqual(result.currentStreak);
    });
  });
});
```

Add the `weekDate` and `prevWeekDate` helpers to the new describe block (or hoist them from the `times_per_week` block so they can be shared).

**Important:** After all updates, run `pnpm test:run` and ALL tests must pass. No test should assert the old Monday-only behavior for weekly or day-level evaluation for weekly stats.
  </action>
  <verify>
Run `pnpm test:run` -- ALL 937+ tests must pass (count may increase due to new weekly tests added).

Run `pnpm lint` -- no lint errors.

Spot check specific test files:
- `pnpm test:run -- tests/lib/habits/format.test.ts` -- all pass, weekly test asserts true for all days
- `pnpm test:run -- tests/lib/habits/heatmap.test.ts` -- all pass, weekly test asserts all days scheduled
- `pnpm test:run -- tests/lib/habits/absence.test.ts` -- all pass, weekly tests assert day-level counts
- `pnpm test:run -- tests/lib/db/habit-logs.test.ts` -- all pass, includes new weekly frequency tests
  </verify>
  <done>
- Test "weekly tracks only Monday" replaced with "weekly tracks every day"
- Test "handles weekly frequency: only Monday is scheduled" replaced with "all days are scheduled"
- Test "handles weekly frequency (Monday only)" updated with correct expected counts
- Test "counts missed weeks for weekly frequency" updated with day-level expected counts
- New tests added for weekly frequency in getDetailedHabitStats and calculateStreak
- `pnpm test:run` passes with 0 failures
- `pnpm lint` passes with 0 errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Functional correctness:** `pnpm test:run` passes all tests (0 failures, no regressions)
2. **Lint clean:** `pnpm lint` reports 0 errors
3. **Deduplication confirmed:** `grep -rn "private shouldTrackOnDate" lib/` returns 0 results
4. **Single source:** `grep -rn "shouldTrackOnDate" lib/` shows definition only in `lib/habits/format.ts` and imports in other files
5. **No Monday hardcoding:** `grep -rn "dayOfWeek === 1" lib/habits/format.ts` returns 0 results
6. **Weekly routes to calculateWeeklyStreak:** `grep -n "calculateWeeklyStreak" lib/db/habit-logs.ts` shows both `times_per_week` and `weekly` routing
7. **Build succeeds:** `pnpm build` completes without errors
</verification>

<success_criteria>
1. `shouldTrackOnDate({ type: 'weekly' }, anyDate)` returns `true` for any day of the week
2. Only one `shouldTrackOnDate` definition exists in the codebase (in `lib/habits/format.ts`)
3. A weekly habit completed once in a week shows 100% completion rate for that week
4. Weekly streak counts consecutive weeks with 1+ completion (using `calculateWeeklyStreak` with targetPerWeek=1)
5. Monthly completion rate for weekly habits counts weeks, not individual days
6. Insights computePerHabitRates evaluates weekly/times_per_week at week level
7. All tests pass including updated assertions for correct frequency behavior
8. `pnpm build` and `pnpm lint` succeed
</success_criteria>

<output>
After completion, create `.planning/phases/01-frequency-correctness/01-01-SUMMARY.md`
</output>
